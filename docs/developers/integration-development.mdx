---
sidebar_position: 3
title: Building Integrations
description: Create custom integrations for Agent Hub - Guide for developers and AI coding agents
hide_table_of_contents: true
---

import AiQuickStart from '@site/src/components/AiQuickStart';
import InfoCallout from '@site/src/components/InfoCallout';
import FileTree, { file, folder } from '@site/src/components/FileTree';

# Building Integrations

<AiQuickStart
  title="Want to get started quickly?"
  description="Copy this prompt and pass it to your AI coding agent (Claude, ChatGPT, Cursor, etc.)."
  prompt={`I want to create a new integration for Agent Hub.

Please help me build it:

1. First, read the integration development guide at the URL below to understand the architecture
2. Then ask me questions about:
   - What service/API I want to integrate
   - Link to API documentation (if available)
   - What actions I need (start with 1-2 core actions)
   - How the API authenticates (API key, OAuth, etc.)
3. Create the integration files in the API codebase at: sb-api-services-v2/src/integrations/[service_name]/
4. Guide me through testing:
   - Restart the API server
   - Configure API keys in the UI
   - Test the connection
   - Create a test agent and verify the actions work

Keep asking questions until you have everything you need. Start simple - we can add more actions later.`}
/>

This guide explains how to create custom integrations for Agent Hub. It's designed for both human developers and AI coding agents.

<InfoCallout title="Plugin Architecture">
Agent Hub uses a **plugin-based architecture**. New integrations are automatically discovered at startup - no registry modifications or hardcoded mappings required. Just add your integration folder and restart the server.
</InfoCallout>

## Codebase Location

All integrations live in the **sb-api-services-v2** repository:

```
sb-api-services-v2/src/integrations/
```

This is the API backend codebase. When creating a new integration, you'll add files to this directory.

## Quick Start

To create a new integration:

1. Navigate to `sb-api-services-v2/src/integrations/`
2. Create a folder: `your_service/`
3. Add `integration.config.json` with metadata
4. Add `your_service.actions.ts` with action definitions
5. Optionally add `your_service.service.ts` for business logic
6. Restart the API server - your integration is auto-discovered

## Integration Structure

<FileTree
  root="sb-api-services-v2/src/integrations/your_service/"
  items={[
    file('integration.config.json', 'Required: Metadata and API key definitions'),
    file('your_service.actions.ts', 'Required: Action definitions and handlers'),
    file('your_service.service.ts', 'Optional: Business logic and API calls'),
    folder('translations/', [
      file('en.json'),
      file('he.json'),
    ], 'Optional: i18n support'),
  ]}
/>

## Step 1: Configuration File

Create `integration.config.json` with your integration metadata:

```json
{
  "name": "your_service",
  "displayName": "Your Service",
  "description": "Brief description of what this integration does",
  "icon": "plug",
  "category": "utilities",
  "actionCreator": "createYourServiceActions",
  "actionsFile": "your_service.actions.ts",
  "requiredApiKeys": [
    {
      "key": "your_service_api_key",
      "label": "API Key",
      "type": "secret",
      "placeholder": "sk-xxxx",
      "description": "Your API key from the service dashboard",
      "helpUrl": "https://example.com/api-keys"
    }
  ]
}
```

### Configuration Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | Yes | Unique identifier (snake_case, must match folder name) |
| `displayName` | string | No | Human-readable name for UI |
| `description` | string | No | Brief description of the integration |
| `icon` | string | No | Lucide icon name or service identifier |
| `category` | string | No | Grouping for UI display |
| `actionCreator` | string | Yes | Exported function name in actions file |
| `actionsFile` | string | No | Actions file name (defaults to `{name}.actions.ts`) |
| `requiredApiKeys` | array | No | Credentials required by the integration |

### API Key Structure

Each entry in `requiredApiKeys` defines a credential field:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `key` | string | Yes | Unique credential identifier (stored encrypted) |
| `label` | string | Yes | Display label in UI |
| `type` | `"secret"` | Yes | Always use `"secret"` for all credentials |
| `placeholder` | string | No | Input placeholder text |
| `description` | string | No | Help text shown below input |
| `helpUrl` | string | No | Link to documentation for getting credentials |

<InfoCallout title="Always Use type: secret">
**Important:** Always use `type: "secret"` for ALL credential fields, including URLs and non-sensitive values. The `type: "text"` option has known issues where values may not be saved correctly by the UI. Even for fields like domains or URLs that aren't technically secrets, use `type: "secret"` to ensure they persist properly.
</InfoCallout>

### Available Categories

| Category | Description |
|----------|-------------|
| `ai` | AI and ML services |
| `communication` | Email, messaging, notifications |
| `project_management` | Issue tracking, project tools |
| `database` | Data storage and retrieval |
| `development` | Developer tools and utilities |
| `hospitality` | Hotel/booking systems |
| `internal` | Platform-internal integrations |
| `utilities` | General purpose tools |

## Step 2: Actions File

Create `your_service.actions.ts` with your action definitions:

```typescript
import {
  ActionContext,
  FunctionFactory,
  StandardActionResult,
} from '../actions/types';
import { executeAction } from '../actions/executor';
import { ActionValidationError } from '../../utils/actionErrors';
import { TestConnectionResult } from '../../services/integration-config.service';

/**
 * Validate connection with the external service
 * Called when user clicks "Test Connection" in the UI
 */
export async function validateConnection(
  apiKeys: Record<string, string>,
): Promise<TestConnectionResult> {
  const apiKey = apiKeys.your_service_api_key;

  if (!apiKey) {
    return {
      success: false,
      error: 'API key is not configured',
    };
  }

  try {
    // Make a minimal API call to verify credentials
    const response = await fetch('https://api.yourservice.com/v1/verify', {
      headers: { Authorization: `Bearer ${apiKey}` },
    });

    if (response.ok) {
      return {
        success: true,
        message: 'Connected successfully to Your Service API',
      };
    }

    return {
      success: false,
      error: 'Invalid API key',
    };
  } catch (error: any) {
    return {
      success: false,
      error: error.message || 'Failed to connect',
    };
  }
}

/**
 * Action creator function - returns all available actions
 * Called with context when actions are executed
 */
export const createYourServiceActions = (
  context: ActionContext,
): FunctionFactory => ({

  yourActionName: {
    description: 'Clear description of what this action does',
    strict: true,  // Enforce strict parameter validation
    parameters: {
      type: 'object',
      properties: {
        requiredParam: {
          type: 'string',
          description: 'What this parameter is for',
        },
        optionalParam: {
          type: 'string',
          enum: ['option1', 'option2'],
          description: 'Optional parameter with allowed values',
        },
      },
      required: ['requiredParam'],
      additionalProperties: false,
    },
    function: async (args: {
      requiredParam: string;
      optionalParam?: string;
    }): Promise<StandardActionResult<YourResponseType>> => {
      // Validate context
      if (!context.companyId) {
        throw new ActionValidationError('Company ID is missing from context.');
      }

      // Execute the action with error handling
      return executeAction<YourResponseType, ServiceResponse>(
        'yourActionName',
        async () => {
          // Your business logic here
          // API keys are fetched automatically using context.companyId
          const result = await yourServiceFunction(context.companyId, args);
          return { success: true, data: result };
        },
        { serviceName: 'yourService' },
      );
    },
  },
});
```

### ActionContext

Every action receives context about the current execution:

```typescript
interface ActionContext {
  sessionId: string;      // Current chat session ID
  companyId: string;      // Company executing the action (for API key lookup)
  userId?: string;        // User ID if available
  assistantId?: string;   // Agent/assistant executing the action
  language: 'en' | 'he';  // UI language preference
  isStateless?: boolean;  // True for stateless API calls
}
```

### StandardActionResult

All actions must return this format:

```typescript
interface StandardActionResult<T = any> {
  success: true;
  message?: string;  // Optional human-readable message
  data?: T;          // The action's result data
}
```

### Error Handling

Throw exceptions rather than returning error objects. Use these error types:

```typescript
import { ActionValidationError } from '../../utils/actionErrors';

// For invalid parameters
throw new ActionValidationError('Parameter X must be a non-empty string');

// For general errors
throw new Error('Failed to connect to service');
```

The framework catches exceptions and returns them to the LLM appropriately.

## Step 3: Service Layer (Optional)

For complex integrations, separate business logic into a service file:

```typescript
// your_service.service.ts
import axios from 'axios';
import { getApiKey } from '../../services/api.key.service';

// Helper to get all required credentials
async function getCredentials(companyId: string) {
  const apiKey = await getApiKey(companyId, 'your_service_api_key');
  const baseUrl = await getApiKey(companyId, 'your_service_url');

  if (!apiKey || !baseUrl) {
    throw new Error('Missing configuration. Please configure API key and URL.');
  }

  return { apiKey, baseUrl: baseUrl.replace(/\/$/, '') };
}

export async function performAction(
  companyId: string,
  params: ActionParams,
): Promise<ActionResult> {
  const { apiKey, baseUrl } = await getCredentials(companyId);

  try {
    const response = await axios.post(
      `${baseUrl}/v1/action`,
      params,
      {
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json',
        },
        timeout: 30000,
      }
    );
    return response.data;
  } catch (error: any) {
    // Handle common error cases
    if (error.response?.status === 502) {
      throw new Error('Service is waking up. Please retry in a few seconds.');
    }
    throw new Error(
      error.response?.data?.error || error.message || 'Action failed'
    );
  }
}

// Validate connection (called by Test Connection button)
export async function validateConnection(
  apiKeys: Record<string, string>
): Promise<{ success: boolean; message?: string; error?: string }> {
  const { your_service_api_key, your_service_url } = apiKeys || {};

  if (!your_service_api_key || !your_service_url) {
    return { success: false, error: 'Missing API key or URL' };
  }

  try {
    const response = await axios.get(
      `${your_service_url.replace(/\/$/, '')}/health`,
      {
        headers: { 'Authorization': `Bearer ${your_service_api_key}` },
        timeout: 10000,
      }
    );

    return response.status === 200
      ? { success: true, message: 'Connected successfully' }
      : { success: false, error: `Unexpected status: ${response.status}` };
  } catch (error: any) {
    return { success: false, error: error.message || 'Connection failed' };
  }
}
```

## Step 4: Translations (Optional)

Add `translations/en.json` for localized descriptions:

```json
{
  "serviceName": "Your Service",
  "serviceDescription": "Integration with Your Service for doing X",
  "yourActionName": {
    "actionTitle": "Do Something",
    "description": "Performs the action with the given parameters"
  }
}
```

## Testing Your Integration

### 1. Verify Auto-Discovery

After creating your integration and restarting the server:

```bash
# Check if your integration is discovered
curl -H "Authorization: Bearer YOUR_API_KEY" \
  https://api.singularitybridge.net/api/integrations/discover/lean
```

Your integration should appear in the list.

### 2. Configure API Keys in UI

1. Open Agent Hub UI
2. Navigate to **Admin > Integrations**
3. Find your integration and click on it
4. Enter your API credentials
5. Click **Test Connection** to verify

### 3. Create a Test Agent

Use the Agent Hub MCP to create a test agent with your integration's actions:

```javascript
// Via MCP tools
await mcp.create_agent({
  name: "your-service-tester",
  description: "Test agent for Your Service integration",
  llmProvider: "openai",
  llmModel: "gpt-5.1",
  systemPrompt: `You are a test agent for the Your Service integration.

Available actions:
- yourActionName: Does X with parameters Y

Test each action and report results.`,
  allowedActions: ["your_service.yourActionName"]
});
```

### 4. Test Actions Directly

Execute actions via the API without going through an agent:

```bash
curl -X POST \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"data": {"requiredParam": "value"}}' \
  https://api.singularitybridge.net/api/integrations/actions/your_service/yourActionName
```

## Real-World Examples

Study these existing integrations in `sb-api-services-v2/src/integrations/` as references:

| Integration | Path | Complexity | Features |
|-------------|------|------------|----------|
| `perplexity` | `src/integrations/perplexity/` | Simple | Single API key, one action |
| `opencode_sandbox` | `src/integrations/opencode_sandbox/` | Medium | Multiple credentials, async operations, connection validation |
| `jira` | `src/integrations/jira/` | Medium | Multiple API keys, multiple actions |
| `openai` | `src/integrations/openai/` | Complex | Multiple actions, file handling |
| `elevenlabs` | `src/integrations/elevenlabs/` | Medium | Audio generation, voice cloning |

### Example: Perplexity (Simple)

**integration.config.json:**
```json
{
  "name": "perplexity",
  "displayName": "Perplexity",
  "description": "AI-powered search and research assistant",
  "icon": "search",
  "category": "ai",
  "actionCreator": "createPerplexityActions",
  "actionsFile": "perplexity.actions.ts",
  "requiredApiKeys": [
    {
      "key": "perplexity_api_key",
      "label": "API Key",
      "type": "secret",
      "placeholder": "pplx-...",
      "description": "Your Perplexity API key"
    }
  ]
}
```

### Example: JIRA (Multiple Credentials)

**integration.config.json:**
```json
{
  "name": "jira",
  "displayName": "JIRA",
  "description": "Project management and issue tracking",
  "icon": "jira",
  "category": "project_management",
  "actionCreator": "createJiraActions",
  "actionsFile": "jira.actions.ts",
  "requiredApiKeys": [
    {
      "key": "jira_api_token",
      "label": "API Token",
      "type": "secret",
      "placeholder": "Your JIRA API token",
      "description": "Generate from Atlassian account settings",
      "helpUrl": "https://id.atlassian.com/manage-profile/security/api-tokens"
    },
    {
      "key": "jira_domain",
      "label": "Domain",
      "type": "secret",
      "placeholder": "your-company",
      "description": "Your Atlassian domain (e.g., your-company.atlassian.net)"
    },
    {
      "key": "jira_email",
      "label": "Email",
      "type": "secret",
      "placeholder": "user@company.com",
      "description": "Email associated with your JIRA account"
    }
  ]
}
```

### Example: OpenCode Sandbox (Async Operations)

This integration demonstrates handling async operations and proper credential configuration:

**integration.config.json:**
```json
{
  "name": "opencode_sandbox",
  "displayName": "OpenCode Sandbox",
  "description": "Remote AI coding agent for code modifications",
  "icon": "code",
  "category": "development",
  "actionCreator": "createOpencodeSandboxActions",
  "actionsFile": "opencode_sandbox.actions.ts",
  "requiredApiKeys": [
    {
      "key": "opencode_server_url",
      "label": "Server URL",
      "type": "secret",
      "placeholder": "https://your-app.fly.dev/opencode",
      "description": "OpenCode server base URL"
    },
    {
      "key": "opencode_server_password",
      "label": "Server Password",
      "type": "secret",
      "placeholder": "your-password",
      "description": "Basic auth password for OpenCode server"
    }
  ]
}
```

**Key patterns in this integration:**
- Uses `axios` with basic auth for API calls
- Separates service logic into `opencode_sandbox.service.ts`
- Implements `validateConnection` for the "Test Connection" button
- Uses `getApiKey(companyId, 'key_name')` for credential retrieval
- Returns async operation results with polling guidance

## Best Practices

1. **Validate inputs** - Use JSON Schema with `strict: true` and `additionalProperties: false`
2. **Return structured data** - Makes it easier for agents to use results
3. **Throw on errors** - Let the framework handle error responses
4. **Log with context** - Include company/session IDs for debugging
5. **Keep actions focused** - One action, one responsibility
6. **Use descriptive names** - Action names become tool names for the LLM
7. **Document parameters** - Good descriptions help the LLM use tools correctly
8. **Implement validateConnection** - Enables "Test Connection" button in UI

## API Reference

### Discovery Endpoints

```bash
# List all integrations (lean)
GET /api/integrations/discover/lean

# List all actions with full details
GET /api/integrations/discover

# Get specific action details
GET /api/integrations/discover/action/:actionId
```

### Configuration Endpoints

```bash
# Get integration config status
GET /api/integrations/:id/config

# Save API keys
POST /api/integrations/:id/config
Body: { "apiKeys": [{ "key": "...", "value": "..." }] }

# Test connection
POST /api/integrations/:id/test-connection

# Delete configuration
DELETE /api/integrations/:id/config
```

### Action Execution

```bash
# Execute action directly
POST /api/integrations/actions/:integrationName/:actionName
Body: { "data": { ...params } }
```

## Troubleshooting

### Integration not appearing after restart

1. Check `integration.config.json` is valid JSON
2. Verify `name` matches the folder name
3. Check server logs for discovery errors
4. Ensure `actionCreator` matches the exported function name

### "Test Connection" fails

1. Verify `validateConnection` is exported from actions file
2. Check API key names match between config and validation function
3. Test the API call manually with curl

### API keys not saving or "Missing API key" errors

**Symptom:** You configure API keys in the UI, click Save, but the integration still shows "Missing API key" or credentials aren't found.

**Cause:** Using `type: "text"` instead of `type: "secret"` in `requiredApiKeys`.

**Solution:** Change ALL credential fields to `type: "secret"`:

```json
// ❌ WRONG - values may not persist
{
  "key": "my_server_url",
  "type": "text",  // This doesn't save properly!
  ...
}

// ✅ CORRECT - always use secret
{
  "key": "my_server_url",
  "type": "secret",  // Works for URLs, domains, etc.
  ...
}
```

### Actions not available to agents

1. Verify actions are listed in `/api/integrations/discover`
2. Check agent's `allowedActions` includes your integration
3. Ensure action names follow `integration.actionName` format

### Action execution fails with context errors

1. Ensure you validate `context.companyId` exists before using it
2. Use `getApiKey(context.companyId, 'key_name')` for credential lookup
3. Wrap business logic in `executeAction()` for consistent error handling
